namespace ccxt;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

public partial class zerodha : Exchange
{
    public override object describe()
    {
        return this.deepExtend(base.describe(), new Dictionary<string, object>() {
            { "id", "zerodha" },
            { "name", "Zerodha" },
            { "countries", new List<object>() {"IN"} },
            { "rateLimit", 100 },
            { "version", "v3" },
            { "certified", false },
            { "pro", false },
            { "has", new Dictionary<string, object>() {
                { "CORS", null },
                { "spot", true },
                { "margin", false },
                { "swap", false },
                { "future", false },
                { "option", false },
                { "cancelOrder", true },
                { "createOrder", true },
                { "fetchBalance", true },
                { "fetchClosedOrders", true },
                { "fetchMarkets", true },
                { "fetchMyTrades", true },
                { "fetchOHLCV", true },
                { "fetchOpenOrders", true },
                { "fetchOrder", true },
                { "fetchTicker", true },
                { "fetchTickers", true },
            } },
            { "timeframes", new Dictionary<string, object>() {
                { "1m", "minute" },
                { "3m", "3minute" },
                { "5m", "5minute" },
                { "10m", "10minute" },
                { "15m", "15minute" },
                { "30m", "30minute" },
                { "1h", "60minute" },
                { "1d", "day" },
            } },
            { "urls", new Dictionary<string, object>() {
                { "logo", "https://zerodha.com/static/images/logo.svg" },
                { "api", new Dictionary<string, object>() {
                    { "public", "https://api.kite.trade" },
                    { "private", "https://api.kite.trade" },
                } },
                { "www", "https://zerodha.com" },
                { "doc", new List<object>() {"https://kite.trade/docs/connect/v3/"} },
                { "fees", "https://zerodha.com/pricing" },
            } },
            { "api", new Dictionary<string, object>() {
                { "public", new Dictionary<string, object>() {
                    { "get", new List<object>() {"instruments", "instruments/{exchange}", "quote", "quote/ltp", "quote/ohlc"} },
                } },
                { "private", new Dictionary<string, object>() {
                    { "get", new List<object>() {"user/profile", "user/margins", "user/margins/{segment}", "portfolio/positions", "portfolio/holdings", "orders", "orders/{order_id}", "trades", "trades/{order_id}", "instruments/historical/{instrument_token}/{interval}"} },
                    { "post", new List<object>() {"orders/{variety}", "orders/{variety}/{order_id}", "portfolio/positions"} },
                    { "put", new List<object>() {"orders/{variety}/{order_id}"} },
                    { "delete", new List<object>() {"orders/{variety}/{order_id}"} },
                } },
            } },
            { "fees", new Dictionary<string, object>() {
                { "trading", new Dictionary<string, object>() {
                    { "tierBased", false },
                    { "percentage", true },
                    { "maker", this.parseNumber("0.0") },
                    { "taker", this.parseNumber("0.0325") },
                } },
            } },
            { "requiredCredentials", new Dictionary<string, object>() {
                { "apiKey", true },
                { "secret", true },
                { "password", false },
                { "login", false },
                { "privateKey", false },
                { "walletAddress", false },
                { "token", false },
            } },
            { "exceptions", new Dictionary<string, object>() {
                { "exact", new Dictionary<string, object>() {
                    { "TokenException", typeof(AuthenticationError) },
                    { "UserException", typeof(PermissionDenied) },
                    { "OrderException", typeof(InvalidOrder) },
                    { "InputException", typeof(BadRequest) },
                    { "MarginException", typeof(InsufficientFunds) },
                    { "HoldingException", typeof(InsufficientFunds) },
                    { "NetworkException", typeof(NetworkError) },
                    { "DataException", typeof(ExchangeError) },
                    { "GeneralException", typeof(ExchangeError) },
                } },
                { "broad", new Dictionary<string, object>() {
                    { "Invalid API credentials", typeof(AuthenticationError) },
                    { "Insufficient funds", typeof(InsufficientFunds) },
                    { "Order not found", typeof(InvalidOrder) },
                    { "Rate limit exceeded", typeof(RateLimitExceeded) },
                } },
            } },
            { "precisionMode", TICK_SIZE },
            { "paddingMode", "NO_PADDING" },
        });
    }

    public async override Task<object> fetchMarkets(object parameters = null)
    {
        /**
        * @method
        * @name zerodha#fetchMarkets
        * @description fetches all available trading instruments and creates unified market structure
        * @see https://kite.trade/docs/connect/v3/market/
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object[]} an array of objects representing market data
        */
        parameters ??= new Dictionary<string, object>();
        object response = await this.publicGetInstruments(parameters);
        object markets = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(response)); postFixIncrement(ref i))
        {
            object market = getValue(response, i);
            object exchange = this.safeString(market, "exchange");
            object tradingSymbol = this.safeString(market, "tradingsymbol");
            object instrumentType = this.safeString(market, "instrument_type");
            // Focus on equity instruments for now (extensible to F&O later)
            if (isTrue(isEqual(instrumentType, "EQ")))
            {
                object id = this.safeString(market, "instrument_token");
                object bs = add(add(exchange, ":"), tradingSymbol);
                object quote = "INR";
                object symbol = add(add(bs, "/"), quote);
                // Parse precision from tick_size
                object tickSize = this.safeNumber(market, "tick_size", 0.05);
                object lotSize = this.safeInteger(market, "lot_size", 1);
                ((IList<object>)markets).Add(new Dictionary<string, object>() {
                    { "id", id },
                    { "symbol", symbol },
                    { "base", bs },
                    { "quote", quote },
                    { "settle", null },
                    { "baseId", tradingSymbol },
                    { "quoteId", "INR" },
                    { "settleId", null },
                    { "type", "spot" },
                    { "spot", true },
                    { "margin", false },
                    { "swap", false },
                    { "future", false },
                    { "option", false },
                    { "active", true },
                    { "contract", false },
                    { "linear", null },
                    { "inverse", null },
                    { "contractSize", null },
                    { "expiry", null },
                    { "expiryDatetime", null },
                    { "strike", null },
                    { "optionType", null },
                    { "precision", new Dictionary<string, object>() {
                        { "amount", lotSize },
                        { "price", tickSize },
                    } },
                    { "limits", new Dictionary<string, object>() {
                        { "leverage", new Dictionary<string, object>() {
                            { "min", null },
                            { "max", null },
                        } },
                        { "amount", new Dictionary<string, object>() {
                            { "min", lotSize },
                            { "max", null },
                        } },
                        { "price", new Dictionary<string, object>() {
                            { "min", tickSize },
                            { "max", null },
                        } },
                        { "cost", new Dictionary<string, object>() {
                            { "min", null },
                            { "max", null },
                        } },
                    } },
                    { "created", null },
                    { "info", market },
                });
            }
        }
        return markets;
    }

    public async override Task<object> fetchTicker(object symbol, object parameters = null)
    {
        /**
        * @method
        * @name zerodha#fetchTicker
        * @description fetches a price ticker
        * @see https://kite.trade/docs/connect/v3/market/
        * @param {string} symbol unified symbol of the market to fetch the ticker for
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a ticker structure
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        // Zerodha quote endpoint expects format 'EXCHANGE:TRADINGSYMBOL'
        object instrument = add(add(getValue(getValue(market, "info"), "exchange"), ":"), getValue(getValue(market, "info"), "tradingsymbol"));
        object request = new Dictionary<string, object>() {
            { "i", instrument },
        };
        object response = await this.publicGetQuote(this.extend(request, parameters));
        object tickerData = this.safeValue(getValue(response, "data"), instrument);
        return this.parseTicker(tickerData, market);
    }

    public override object parseTicker(object ticker, object market = null)
    {
        object timestamp = this.parse8601(this.safeString(ticker, "timestamp"));
        object last = this.safeNumber(ticker, "last_price");
        object ohlc = this.safeValue(ticker, "ohlc", new Dictionary<string, object>() {});
        object depth = this.safeValue(ticker, "depth", new Dictionary<string, object>() {});
        object buyDepth = this.safeValue(depth, "buy", new List<object>() {});
        object sellDepth = this.safeValue(depth, "sell", new List<object>() {});
        object bid = ((bool) isTrue((isGreaterThan(getArrayLength(buyDepth), 0)))) ? this.safeNumber(getValue(buyDepth, 0), "price") : null;
        object ask = ((bool) isTrue((isGreaterThan(getArrayLength(sellDepth), 0)))) ? this.safeNumber(getValue(sellDepth, 0), "price") : null;
        object bidVolume = ((bool) isTrue((isGreaterThan(getArrayLength(buyDepth), 0)))) ? this.safeNumber(getValue(buyDepth, 0), "quantity") : null;
        object askVolume = ((bool) isTrue((isGreaterThan(getArrayLength(sellDepth), 0)))) ? this.safeNumber(getValue(sellDepth, 0), "quantity") : null;
        object symbol = this.safeString(market, "symbol");
        return this.safeTicker(new Dictionary<string, object>() {
            { "symbol", symbol },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "high", this.safeNumber(ohlc, "high") },
            { "low", this.safeNumber(ohlc, "low") },
            { "bid", bid },
            { "bidVolume", bidVolume },
            { "ask", ask },
            { "askVolume", askVolume },
            { "vwap", null },
            { "open", this.safeNumber(ohlc, "open") },
            { "close", last },
            { "last", last },
            { "previousClose", this.safeNumber(ohlc, "close") },
            { "change", null },
            { "percentage", null },
            { "average", null },
            { "baseVolume", this.safeNumber(ticker, "volume") },
            { "quoteVolume", null },
            { "info", ticker },
        }, market);
    }

    public async override Task<object> fetchTickers(object symbols = null, object parameters = null)
    {
        /**
        * @method
        * @name zerodha#fetchTickers
        * @description fetches price tickers for multiple symbols
        * Implemented by making multiple fetchTicker calls due to Zerodha API limitations
        * @see https://kite.trade/docs/connect/v3/market/
        * @param {string[]} [symbols] unified symbols of the markets to fetch the ticker for, all market tickers are returned if not assigned
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a dictionary of ticker structures
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        if (isTrue(isEqual(symbols, null)))
        {
            symbols = this.symbols;
        } else if (isTrue((symbols is string)))
        {
            symbols = new List<object>() {symbols};
        }
        // For large numbers of symbols, we should consider batching to avoid rate limits
        // Zerodha allows 10 requests per second, so we batch the requests
        object tickers = new Dictionary<string, object>() {};
        // Use batch processing to respect rate limits
        object batchSize = 8; // Conservative batch size to stay under rate limits
        for (object i = 0; isLessThan(i, getArrayLength(symbols)); i = add(i, batchSize))
        {
            object batchSymbols = slice(symbols, i, add(i, batchSize));
            // Make concurrent requests for each batch
            for (object j = 0; isLessThan(j, getArrayLength(batchSymbols)); postFixIncrement(ref j))
            {
                object symbol = getValue(batchSymbols, j);
                try
                {
                    object ticker = await this.fetchTicker(symbol, parameters);
                    ((IDictionary<string,object>)tickers)[(string)symbol] = ticker;
                } catch(Exception e)
                {
                    continue;
                }
            }
            // Small delay between batches to respect rate limits (100ms as per rateLimit)
            if (isTrue(isLessThan(add(i, batchSize), getArrayLength(symbols))))
            {
                await this.sleep(100); // 100ms delay
            }
        }
        return tickers;
    }

    public async override Task<object> fetchOHLCV(object symbol, object timeframe = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name zerodha#fetchOHLCV
        * @description fetches historical candlestick data
        * @see https://kite.trade/docs/connect/v3/historical/
        * @param {string} symbol unified symbol of the market to fetch OHLCV data for
        * @param {string} timeframe the length of time each candle represents
        * @param {int} [since] timestamp in ms of the earliest candle to fetch
        * @param {int} [limit] the maximum amount of candles to fetch
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
        */
        timeframe ??= "1m";
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "instrument_token", getValue(market, "id") },
            { "interval", this.safeString(this.timeframes, timeframe, timeframe) },
        };
        // Calculate date range based on since and limit
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["from"] = this.yyyymmdd(since, "-");
        } else
        {
            // Default to last 30 days if no since parameter
            object now = this.milliseconds();
            object thirtyDaysAgo = subtract(now, (multiply(multiply(multiply(multiply(30, 24), 60), 60), 1000)));
            ((IDictionary<string,object>)request)["from"] = this.yyyymmdd(thirtyDaysAgo, "-");
        }
        // Set 'to' date to today
        ((IDictionary<string,object>)request)["to"] = this.yyyymmdd(this.milliseconds(), "-");
        object response = await this.privateGetInstrumentsHistoricalInstrumentTokenInterval(this.extend(request, parameters));
        object candles = this.safeValue(getValue(response, "data"), "candles", new List<object>() {});
        return this.parseOHLCVs(candles, market, timeframe, since, limit);
    }

    public override object parseOHLCV(object ohlcv, object market = null)
    {
        timeframe ??= "1m";
        return new List<object> {this.parse8601(getValue(ohlcv, 0)), this.safeNumber(ohlcv, 1), this.safeNumber(ohlcv, 2), this.safeNumber(ohlcv, 3), this.safeNumber(ohlcv, 4), this.safeNumber(ohlcv, 5)};
    }

    public async override Task<object> fetchBalance(object parameters = null)
    {
        /**
        * @method
        * @name zerodha#fetchBalance
        * @description query for balance and get the amount of funds available for trading
        * @see https://kite.trade/docs/connect/v3/user/
        * @see https://kite.trade/docs/connect/v3/portfolio/
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a balance structure
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        // Fetch both cash margins and stock holdings
        var marginResponseholdingsResponseVariable = await promiseAll(new List<object> {this.privateGetUserMargins(parameters), this.privateGetPortfolioHoldings(parameters)});
        var marginResponse = ((IList<object>) marginResponseholdingsResponseVariable)[0];
        var holdingsResponse = ((IList<object>) marginResponseholdingsResponseVariable)[1];
        object result = new Dictionary<string, object>() {
            { "info", new Dictionary<string, object>() {
                { "margins", marginResponse },
                { "holdings", holdingsResponse },
            } },
        };
        // Parse cash balance from margins
        object equityMargins = this.safeValue(getValue(marginResponse, "data"), "equity");
        if (isTrue(equityMargins))
        {
            object available = this.safeValue(equityMargins, "available", new Dictionary<string, object>() {});
            object cashAvailable = this.safeNumber(available, "cash", 0);
            object netBalance = this.safeNumber(equityMargins, "net", 0);
            ((IDictionary<string,object>)result)["INR"] = this.account();
            ((IDictionary<string,object>)getValue(result, "INR"))["free"] = cashAvailable;
            ((IDictionary<string,object>)getValue(result, "INR"))["total"] = netBalance;
            ((IDictionary<string,object>)getValue(result, "INR"))["used"] = mathMax(0, subtract(netBalance, cashAvailable));
        }
        // Parse stock holdings
        object holdings = this.safeValue(holdingsResponse, "data", new List<object>() {});
        for (object i = 0; isLessThan(i, getArrayLength(holdings)); postFixIncrement(ref i))
        {
            object holding = getValue(holdings, i);
            object tradingSymbol = this.safeString(holding, "tradingsymbol");
            object exchange = this.safeString(holding, "exchange");
            object quantity = this.safeNumber(holding, "quantity", 0);
            // Find the market to get unified symbol
            object marketId = add(add(add(exchange, ":"), tradingSymbol), "/INR");
            object market = this.safeMarket(marketId);
            if (isTrue(isTrue(market) && isTrue(isGreaterThan(quantity, 0))))
            {
                object bs = getValue(market, "base");
                ((IDictionary<string,object>)result)[(string)bs] = this.account();
                ((IDictionary<string,object>)getValue(result, bs))["total"] = quantity;
                ((IDictionary<string,object>)getValue(result, bs))["free"] = quantity; // Assuming all holdings are free to trade
                ((IDictionary<string,object>)getValue(result, bs))["used"] = 0;
            }
        }
        return this.safeBalance(result);
    }

    public async override Task<object> createOrder(object symbol, object type, object side, object amount, object price = null, object parameters = null)
    {
        /**
        * @method
        * @name zerodha#createOrder
        * @description create a trade order
        * @see https://kite.trade/docs/connect/v3/orders/
        * @param {string} symbol unified symbol of the market to create an order in
        * @param {string} type 'market' or 'limit'
        * @param {string} side 'buy' or 'sell'
        * @param {float} amount how much of currency you want to trade in units of base currency
        * @param {float} [price] the price at which the order is to be fulfilled, ignored in market orders
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {string} params.product 'CNC' for Cash and Carry, 'MIS' for Margin Intraday (REQUIRED)
        * @param {string} [params.variety] 'regular', 'amo', 'co' (default: 'regular')
        * @param {string} [params.validity] 'DAY', 'IOC' (default: 'DAY')
        * @param {float} [params.trigger_price] trigger price for stop orders
        * @returns {object} an order structure
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        // Product parameter is mandatory for Zerodha
        object product = this.safeString(parameters, "product");
        if (isTrue(isEqual(product, null)))
        {
            throw new InvalidOrder ((string)add(this.id, " createOrder() requires the \"product\" parameter (e.g., \"CNC\", \"MIS\") in params")) ;
        }
        object variety = this.safeString(parameters, "variety", "regular");
        object validity = this.safeString(parameters, "validity", "DAY");
        object request = new Dictionary<string, object>() {
            { "variety", variety },
            { "tradingsymbol", getValue(market, "baseId") },
            { "exchange", getValue(getValue(market, "info"), "exchange") },
            { "transaction_type", ((string)side).ToUpper() },
            { "order_type", ((string)type).ToUpper() },
            { "quantity", this.amountToPrecision(symbol, amount) },
            { "product", ((string)product).ToUpper() },
            { "validity", ((string)validity).ToUpper() },
        };
        if (isTrue(isEqual(type, "limit")))
        {
            if (isTrue(isEqual(price, null)))
            {
                throw new InvalidOrder ((string)add(this.id, " createOrder() requires a price argument for limit orders")) ;
            }
            ((IDictionary<string,object>)request)["price"] = this.priceToPrecision(symbol, price);
        }
        object triggerPrice = this.safeNumber(parameters, "trigger_price");
        if (isTrue(!isEqual(triggerPrice, null)))
        {
            ((IDictionary<string,object>)request)["trigger_price"] = this.priceToPrecision(symbol, triggerPrice);
        }
        object omitted = this.omit(parameters, new List<object>() {"product", "variety", "validity", "trigger_price"});
        object response = await this.privatePostOrdersVariety(this.extend(request, omitted));
        object orderId = this.safeString(getValue(response, "data"), "order_id");
        return this.safeOrder(new Dictionary<string, object>() {
            { "id", orderId },
            { "info", response },
        }, market);
    }

    public async override Task<object> cancelOrder(object id, object symbol = null, object parameters = null)
    {
        /**
        * @method
        * @name zerodha#cancelOrder
        * @description cancels an open order
        * @see https://kite.trade/docs/connect/v3/orders/
        * @param {string} id order id
        * @param {string} symbol unified symbol of the market the order was made in
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {string} [params.variety] 'regular', 'amo', 'co' (default: 'regular')
        * @returns {object} An order structure
        */
        parameters ??= new Dictionary<string, object>();
        object variety = this.safeString(parameters, "variety", "regular");
        object request = new Dictionary<string, object>() {
            { "variety", variety },
            { "order_id", id },
        };
        object omitted = this.omit(parameters, new List<object>() {"variety"});
        object response = await this.privateDeleteOrdersVarietyOrderId(this.extend(request, omitted));
        return this.parseOrder(getValue(response, "data"));
    }

    public async override Task<object> fetchOrder(object id, object symbol = null, object parameters = null)
    {
        /**
        * @method
        * @name zerodha#fetchOrder
        * @description fetches information on an order made by the user
        * @see https://kite.trade/docs/connect/v3/orders/
        * @param {string} id order id
        * @param {string} symbol unified symbol of the market the order was made in
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} An order structure
        */
        parameters ??= new Dictionary<string, object>();
        object request = new Dictionary<string, object>() {
            { "order_id", id },
        };
        object response = await this.privateGetOrdersOrderId(this.extend(request, parameters));
        object orders = this.safeValue(response, "data", new List<object>() {});
        if (isTrue(!isTrue(((orders is IList<object>) || (orders.GetType().IsGenericType && orders.GetType().GetGenericTypeDefinition().IsAssignableFrom(typeof(List<>))))) || isTrue(isEqual(getArrayLength(orders), 0))))
        {
            throw new InvalidOrder ((string)add(add(add(this.id, " order "), id), " not found")) ;
        }
        return this.parseOrder(getValue(orders, 0));
    }

    public async override Task<object> fetchOpenOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name zerodha#fetchOpenOrders
        * @description fetch all unfilled currently open orders
        * @see https://kite.trade/docs/connect/v3/orders/
        * @param {string} symbol unified market symbol
        * @param {int} [since] the earliest time in ms to fetch open orders for
        * @param {int} [limit] the maximum number of open orders structures to retrieve
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {Order[]} a list of order structures
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object response = await this.privateGetOrders(parameters);
        object orders = this.safeValue(response, "data", new List<object>() {});
        object openStatuses = new List<object>() {"OPEN", "TRIGGER PENDING"};
        object openOrders = orders.filter((object order) => openStatuses.Contains(this.safeString(order, "status")));
        return this.parseOrders(openOrders, null, since, limit);
    }

    public async override Task<object> fetchClosedOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name zerodha#fetchClosedOrders
        * @description fetches information on multiple closed orders made by the user
        * @see https://kite.trade/docs/connect/v3/orders/
        * @param {string} symbol unified market symbol of the market orders were made in
        * @param {int} [since] the earliest time in ms to fetch orders for
        * @param {int} [limit] the maximum number of order structures to retrieve
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {Order[]} a list of order structures
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object response = await this.privateGetOrders(parameters);
        object orders = this.safeValue(response, "data", new List<object>() {});
        object closedStatuses = new List<object>() {"COMPLETE", "CANCELLED", "REJECTED"};
        object closedOrders = orders.filter((object order) => closedStatuses.Contains(this.safeString(order, "status")));
        return this.parseOrders(closedOrders, null, since, limit);
    }

    public async override Task<object> fetchMyTrades(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name zerodha#fetchMyTrades
        * @description fetch all trades made by the user
        * @see https://kite.trade/docs/connect/v3/orders/
        * @param {string} symbol unified market symbol
        * @param {int} [since] the earliest time in ms to fetch trades for
        * @param {int} [limit] the maximum number of trades structures to retrieve
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {Trade[]} a list of trade structures
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object response = await this.privateGetTrades(parameters);
        object trades = this.safeValue(response, "data", new List<object>() {});
        return this.parseTrades(trades, null, since, limit);
    }

    public override object parseOrder(object order, object market = null)
    {
        object statusMap = new Dictionary<string, object>() {
            { "OPEN", "open" },
            { "TRIGGER PENDING", "open" },
            { "COMPLETE", "closed" },
            { "CANCELLED", "canceled" },
            { "REJECTED", "rejected" },
        };
        object id = this.safeString(order, "order_id");
        object status = this.safeString(statusMap, this.safeString(order, "status"));
        object exchange = this.safeString(order, "exchange");
        object tradingSymbol = this.safeString(order, "tradingsymbol");
        object marketId = add(add(add(exchange, ":"), tradingSymbol), "/INR");
        market = this.safeMarket(marketId, market);
        object symbol = this.safeString(market, "symbol");
        object timestamp = this.parse8601(this.safeString(order, "order_timestamp"));
        object type = this.safeStringLower(order, "order_type");
        object side = this.safeStringLower(order, "transaction_type");
        object amount = this.safeNumber(order, "quantity");
        object filled = this.safeNumber(order, "filled_quantity");
        object remaining = this.safeNumber(order, "pending_quantity");
        object price = this.safeNumber(order, "price");
        object average = this.safeNumber(order, "average_price");
        object stopPrice = this.safeNumber(order, "trigger_price");
        object cost = null;
        if (isTrue(isTrue(!isEqual(filled, null)) && isTrue(!isEqual(average, null))))
        {
            cost = multiply(filled, average);
        }
        return this.safeOrder(new Dictionary<string, object>() {
            { "info", order },
            { "id", id },
            { "clientOrderId", this.safeString(order, "tag") },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "lastTradeTimestamp", null },
            { "symbol", symbol },
            { "type", type },
            { "timeInForce", this.safeStringUpper(order, "validity") },
            { "postOnly", null },
            { "side", side },
            { "amount", amount },
            { "price", price },
            { "stopPrice", stopPrice },
            { "triggerPrice", stopPrice },
            { "cost", cost },
            { "average", average },
            { "filled", filled },
            { "remaining", remaining },
            { "status", status },
            { "fee", null },
            { "trades", new List<object>() {} },
        }, market);
    }

    public override object parseTrade(object trade, object market = null)
    {
        object id = this.safeString(trade, "trade_id");
        object orderId = this.safeString(trade, "order_id");
        object exchange = this.safeString(trade, "exchange");
        object tradingSymbol = this.safeString(trade, "tradingsymbol");
        object marketId = add(add(add(exchange, ":"), tradingSymbol), "/INR");
        market = this.safeMarket(marketId, market);
        object symbol = this.safeString(market, "symbol");
        object timestamp = this.parse8601(this.safeString(trade, "fill_timestamp"));
        object side = this.safeStringLower(trade, "transaction_type");
        object amount = this.safeNumber(trade, "quantity");
        object price = this.safeNumber(trade, "price");
        object cost = null;
        if (isTrue(isTrue(!isEqual(amount, null)) && isTrue(!isEqual(price, null))))
        {
            cost = multiply(amount, price);
        }
        return this.safeTrade(new Dictionary<string, object>() {
            { "info", trade },
            { "id", id },
            { "order", orderId },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "symbol", symbol },
            { "type", null },
            { "side", side },
            { "amount", amount },
            { "price", price },
            { "cost", cost },
            { "fee", null },
        }, market);
    }

    public override object sign(object path, object api = null, object method = null, object parameters = null, object headers = null, object body = null)
    {
        api ??= "public";
        method ??= "GET";
        parameters ??= new Dictionary<string, object>();
        object url = add(add(getValue(getValue(this.urls, "api"), api), "/"), this.implodeParams(path, parameters));
        object query = this.omit(parameters, this.extractParams(path));
        if (isTrue(isEqual(api, "private")))
        {
            this.checkRequiredCredentials();
            // Check if access token is available
            if (!isTrue(this.password))
            {
                throw new AuthenticationError ((string)add(this.id, " access token is missing. Please provide it in the \"password\" field or use the generate_token.py script.")) ;
            }
            headers = new Dictionary<string, object>() {
                { "X-Kite-Version", this.version },
                { "Authorization", add(add(add("token ", this.apiKey), ":"), this.password) },
            };
        }
        if (isTrue(isEqual(method, "GET")))
        {
            if (isTrue(getArrayLength(new List<object>(((IDictionary<string,object>)query).Keys))))
            {
                url = add(url, add("?", this.urlencode(query)));
            }
        } else
        {
            if (isTrue(getArrayLength(new List<object>(((IDictionary<string,object>)query).Keys))))
            {
                body = this.urlencode(query);
                ((IDictionary<string,object>)headers)["Content-Type"] = "application/x-www-form-urlencoded";
            }
        }
        return new Dictionary<string, object>() {
            { "url", url },
            { "method", method },
            { "body", body },
            { "headers", headers },
        };
    }

    public override object handleErrors(object code, object reason, object url, object method, object headers, object body, object response, object requestHeaders, object requestBody)
    {
        if (isTrue(isEqual(response, null)))
        {
            return;
        }
        // Zerodha API returns errors in this format:
        // {"status": "error", "message": "Error message", "error_type": "TokenException"}
        object status = this.safeString(response, "status");
        if (isTrue(isEqual(status, "error")))
        {
            object errorType = this.safeString(response, "error_type");
            object message = this.safeString(response, "message");
            object feedback = add(add(this.id, " "), message);
            this.throwExactlyMatchedException(getValue(this.exceptions, "exact"), errorType, feedback);
            this.throwBroadlyMatchedException(getValue(this.exceptions, "broad"), message, feedback);
            throw new ExchangeError ((string)feedback) ;
        }
        // Handle rate limit errors
        if (isTrue(isEqual(code, 429)))
        {
            throw new RateLimitExceeded ((string)add(this.id, " rate limit exceeded")) ;
        }
        // Handle server errors
        if (isTrue(isGreaterThanOrEqual(code, 500)))
        {
            throw new ExchangeNotAvailable ((string)add(add(this.id, " server error: "), body)) ;
        }
    }
}
