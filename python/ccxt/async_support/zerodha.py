# -*- coding: utf-8 -*-

# PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
# https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

import asyncio
from typing import List, Dict, Any, Optional
from ccxt.async_support.base.exchange import Exchange
from ccxt.abstract.zerodha import ImplicitAPI
from ccxt.base.types import Int, Num, OrderBook, Str, Ticker, Tickers, Trade, Market, Balances, Order, OrderSide, OrderType
from typing import List
from ccxt.base.errors import ExchangeError, NetworkError, AuthenticationError
from ccxt.zerodha import zerodha as ZerodhaSync
import json
from datetime import datetime
from pathlib import Path


class zerodha(Exchange, ImplicitAPI):
    
    def __init__(self, config={}):
        super().__init__(config)
        self.token_cache_path = Path.home() / '.cache' / 'ccxt-zerodha' / 'session.json'
        self.token_cache_path.parent.mkdir(parents=True, exist_ok=True)
        self.access_token = None
        self.login_time = None
        
        # Load credentials from cache if not provided in config
        if not self.apiKey or not self.access_token:
            self._load_credentials_from_cache()
    
    def describe(self):
        # Use the synchronous implementation's describe method
        sync_exchange = self._get_sync_exchange()
        description = sync_exchange.describe()
        
        # Add features configuration for Freqtrade compatibility
        description['features'] = {
            'spot': {
                'fetchOHLCV': {
                    'limit': 1000,  # Zerodha allows up to 1000 candles per request
                },
                'fetchTicker': {
                    'limit': 1000,
                },
                'fetchTickers': {
                    'limit': 1000,
                },
            },
            'futures': {
                'fetchOHLCV': {
                    'limit': 1000,
                },
                'fetchTicker': {
                    'limit': 1000,
                },
                'fetchTickers': {
                    'limit': 1000,
                },
            },
        }
        
        return description
    
    def _get_sync_exchange(self):
        """Helper method to create a properly configured sync exchange instance"""
        config = {}
        
        # Copy all relevant attributes from the async instance
        attrs_to_copy = [
            'apiKey', 'secret', 'password', 'sandbox', 'verbose', 'timeout',
            'rateLimit', 'enableRateLimit', 'userAgent', 'headers', 'hostname',
            'proxy', 'httpsProxy', 'socksProxy', 'wssProxy', 'version'
        ]
        
        for attr in attrs_to_copy:
            if hasattr(self, attr):
                value = getattr(self, attr)
                if value is not None:
                    config[attr] = value
        
        # Copy dictionaries properly
        dict_attrs = ['urls', 'options', 'requiredCredentials', 'exceptions']
        for attr in dict_attrs:
            if hasattr(self, attr):
                value = getattr(self, attr)
                if value is not None:
                    config[attr] = value
        
        return ZerodhaSync(config)
    
    def sign(self, path, api='public', method='GET', params={}, headers=None, body=None):
        """Sign the request with session-based authentication"""
        url = self.urls['api'][api] + '/' + self.implode_params(path, params)
        query = self.omit(params, self.extract_params(path))
        
        # Always add auth headers for quote endpoints
        if api == 'private' or path in ['quote', 'quote/ltp', 'quote/ohlc']:
            if not self.apiKey or not self.access_token:
                self._load_credentials_from_cache()
            if not self.apiKey or not self.access_token:
                raise AuthenticationError(self.id + ' requires apiKey and access_token for authentication')
            if headers is None:
                headers = {}
            headers['X-KiteConnect-ApiKey'] = self.apiKey
            headers['Authorization'] = f'token {self.apiKey}:{self.access_token}'
        
        if method == 'GET':
            if query:
                url += '?' + self.urlencode(query)
        else:
            if query:
                body = self.urlencode(query)
                if headers is None:
                    headers = {}
                headers['Content-Type'] = 'application/x-www-form-urlencoded'
        
        return {'url': url, 'method': method, 'body': body, 'headers': headers}

    async def fetch_markets(self, params={}) -> List[Market]:
        """
        retrieves data on all markets for zerodha
        @param {dict} params extra parameters specific to the exchange API endpoint
        @returns {dict} an array of objects representing market data
        """
        response = await self.public_get_instruments(params)
        markets = []
        
        # Handle CSV response - Zerodha returns CSV data
        if isinstance(response, str):
            # Parse CSV response
            import csv
            import io
            
            # Split by lines and parse each line
            lines = response.strip().split('\n')
            if len(lines) < 2:  # Need at least header + 1 data row
                return markets
            
            # Parse header
            header = lines[0].split(',')
            
            # Parse data rows
            for line in lines[1:]:
                try:
                    # Split by comma, but handle quoted fields properly
                    row = list(csv.reader([line]))[0]
                    
                    # Create market data dict
                    market_data = {}
                    for i, field in enumerate(row):
                        if i < len(header):
                            market_data[header[i]] = field
                    
                    # Process the market data
                    exchange = market_data.get('exchange', '')
                    trading_symbol = market_data.get('tradingsymbol', '')
                    instrument_type = market_data.get('instrument_type', '')
                    
                    # Focus on equity instruments for now (extensible to F&O later)
                    if instrument_type == 'EQ':
                        id = market_data.get('instrument_token', '')
                        tick_size = float(market_data.get('tick_size', 0.05))
                        lot_size = int(market_data.get('lot_size', 1))
                        
                        # Skip if no instrument token
                        if not id:
                            continue
                        
                        base = exchange + ':' + trading_symbol
                        quote = 'INR'
                        symbol = base + '/' + quote
                        
                        market = {
                            'id': id,
                            'symbol': symbol,
                            'base': base,
                            'quote': quote,
                            'settle': None,
                            'baseId': trading_symbol,
                            'quoteId': 'INR',
                            'settleId': None,
                            'type': 'spot',
                            'spot': True,
                            'margin': False,
                            'swap': False,
                            'future': False,
                            'option': False,
                            'active': True,
                            'contract': False,
                            'linear': None,
                            'inverse': None,
                            'contractSize': None,
                            'expiry': None,
                            'expiryDatetime': None,
                            'strike': None,
                            'optionType': None,
                            'precision': {
                                'amount': lot_size,
                                'price': tick_size,
                            },
                            'limits': {
                                'leverage': {
                                    'min': None,
                                    'max': None,
                                },
                                'amount': {
                                    'min': lot_size,
                                    'max': None,
                                },
                                'price': {
                                    'min': tick_size,
                                    'max': None,
                                },
                                'cost': {
                                    'min': None,
                                    'max': None,
                                },
                            },
                            'created': None,
                            'info': market_data,
                        }
                        markets.append(market)
                        
                except Exception as e:
                    # Log error but continue processing other markets
                    self.log(f"Error processing market data line: {e}")
                    continue
        else:
            # Handle JSON response (fallback)
            for instrument in response:
                try:
                    # Parse the instrument data
                    instrument_token = str(instrument.get('instrument_token', ''))
                    tradingsymbol = instrument.get('tradingsymbol', '')
                    name = instrument.get('name', '')
                    instrument_type = instrument.get('instrument_type', '')
                    exchange = instrument.get('exchange', '')
                    segment = instrument.get('segment', '')
                    
                    # Skip if essential fields are missing
                    if not instrument_token or not tradingsymbol or not exchange:
                        continue
                    
                    # Determine the base and quote currencies
                    if instrument_type == 'EQ':
                        # For equity, the symbol is the base currency
                        base = tradingsymbol
                        quote = 'INR'
                    elif instrument_type in ['FUT', 'OPT']:
                        # For futures/options, extract the underlying
                        base = tradingsymbol.split('-')[0] if '-' in tradingsymbol else tradingsymbol
                        quote = 'INR'
                    else:
                        # For other instruments, use the symbol as base
                        base = tradingsymbol
                        quote = 'INR'
                    
                    # Create the market ID
                    market_id = f"{base}/{quote}"
                    
                    # Create market object
                    market = {
                        'id': instrument_token,
                        'symbol': market_id,
                        'base': base,
                        'quote': quote,
                        'settle': None,
                        'baseId': tradingsymbol,
                        'quoteId': 'INR',
                        'settleId': None,
                        'type': 'spot' if instrument_type == 'EQ' else 'future' if instrument_type == 'FUT' else 'option',
                        'spot': instrument_type == 'EQ',
                        'margin': False,
                        'swap': False,
                        'future': instrument_type == 'FUT',
                        'option': instrument_type == 'OPT',
                        'active': True,
                        'contract': instrument_type in ['FUT', 'OPT'],
                        'linear': True,
                        'inverse': False,
                        'contractSize': 1,
                        'expiry': None,
                        'expiryDatetime': None,
                        'strike': None,
                        'optionType': None,
                        'settlementType': None,
                        'feeLoaded': False,
                        'info': instrument,
                    }
                    
                    markets.append(market)
                    
                except Exception as e:
                    # Skip malformed data
                    continue
        
        return markets

    def parse_market(self, market) -> Market:
        # Use the synchronous implementation's parse_market method
        sync_exchange = self._get_sync_exchange()
        return sync_exchange.parse_market(market)

    async def fetch_ticker(self, symbol: str, params={}) -> Ticker:
        """
        fetches a price ticker for a specific trading symbol
        :param str symbol: unified symbol of the market to fetch the ticker for
        :param dict [params]: extra parameters specific to the exchange API endpoint
        :returns dict: a ticker structure
        """
        await self.load_markets()
        market = self.market(symbol)
        
        # Zerodha quote endpoint expects format 'EXCHANGE:TRADINGSYMBOL'
        instrument = market['info']['exchange'] + ':' + market['info']['tradingsymbol']
        
        request = {
            'i': instrument,
        }
        
        response = await self.public_get_quote(self.extend(request, params))
        ticker_data = self.safe_value(response['data'], instrument)
        
        return self.parse_ticker(ticker_data, market)

    async def fetch_tickers(self, symbols: List[str] = None, params={}) -> Tickers:
        """
        fetches price tickers for multiple symbols
        :param list symbols: unified symbols of the markets to fetch the ticker for
        :param dict [params]: extra parameters specific to the exchange API endpoint
        :returns dict: a dictionary of ticker structures
        """
        await self.load_markets()
        
        if symbols is None:
            symbols = list(self.symbols)
        
        result = {}
        
        # Process symbols in batches to avoid rate limits
        batch_size = 8
        for i in range(0, len(symbols), batch_size):
            batch = symbols[i:i + batch_size]
            
            # Fetch tickers for this batch
            batch_promises = []
            for symbol in batch:
                batch_promises.append(self.fetch_ticker(symbol, params))
            
            # Wait for all tickers in this batch
            batch_tickers = await self.wait_all(batch_promises)
            
            # Add to result
            for j, ticker in enumerate(batch_tickers):
                result[batch[j]] = ticker
            
            # Add delay between batches to respect rate limits
            if i + batch_size < len(symbols):
                await self.sleep(100)  # 100ms delay
        
        return result

    def parse_ticker(self, ticker, market: Market = None) -> Ticker:
        # Use the synchronous implementation's parse_ticker method
        sync_exchange = self._get_sync_exchange()
        return sync_exchange.parse_ticker(ticker, market)

    async def fetch_ohlcv(self, symbol: str, timeframe='1m', since: Int = None, limit: Int = None, params={}) -> List[list]:
        """
        fetches historical candlestick data containing the open, high, low, and close price, and the volume of a market
        :param str symbol: unified symbol of the market to fetch OHLCV data for
        :param str timeframe: the length of time each candle represents
        :param int|None since: timestamp in ms of the earliest candle to fetch
        :param int|None limit: the maximum amount of candles to fetch
        :param dict [params]: extra parameters specific to the exchange API endpoint
        :returns list[list]: A list of candles ordered as timestamp, open, high, low, close, volume
        """
        await self.load_markets()
        market = self.market(symbol)
        
        request = {
            'instrument_token': market['id'],
            'interval': self.safe_string(self.timeframes, timeframe, timeframe),
        }
        
        # Calculate date range based on since and limit
        if since is not None:
            request['from'] = self.yyyymmdd(since, '-')
        else:
            # Default to last 30 days if no since parameter
            now = self.milliseconds()
            thirty_days_ago = now - (30 * 24 * 60 * 60 * 1000)
            request['from'] = self.yyyymmdd(thirty_days_ago, '-')
        
        # Set 'to' date to today
        request['to'] = self.yyyymmdd(self.milliseconds(), '-')
        
        response = await self.private_get_instruments_historical_instrument_token_interval(self.extend(request, params))
        candles = self.safe_value(response['data'], 'candles', [])
        
        return self.parse_ohlcvs(candles, market, timeframe, since, limit)

    def parse_ohlcv(self, ohlcv, market: Market = None) -> list:
        # Use the synchronous implementation's parse_ohlcv method
        sync_exchange = self._get_sync_exchange()
        return sync_exchange.parse_ohlcv(ohlcv, market)

    async def wait_all(self, promises):
        """
        Wait for all promises to complete and return their results
        """
        import asyncio
        return await asyncio.gather(*promises)

    async def sleep(self, milliseconds: int):
        """
        Sleep for the specified number of milliseconds
        """
        import asyncio
        await asyncio.sleep(milliseconds / 1000)

    def _load_credentials_from_cache(self):
        """Load credentials from the cached token file"""
        try:
            if self.token_cache_path.exists():
                with open(self.token_cache_path, 'r') as f:
                    token_data = json.load(f)
                    if not self.apiKey:
                        self.apiKey = token_data.get('api_key')
                    if not self.access_token:
                        self.access_token = token_data.get('access_token')
                    if not self.login_time and token_data.get('login_time'):
                        self.login_time = self.parse8601(token_data.get('login_time'))
        except Exception as e:
            # Silently fail if cache loading fails
            pass

    def _is_token_expired(self):
        """Checks if the access token has expired (past 6 AM IST next day)."""
        if not self.access_token or not self.login_time:
            return True

        import pytz
        from datetime import time
        
        ist = pytz.timezone('Asia/Kolkata')
        now_ist = datetime.now(ist)
        expiry_time = time(6, 0)
        
        if hasattr(self.login_time, 'tzinfo') and self.login_time.tzinfo is not None:
            login_date = self.login_time.date()
        else:
            # If no timezone info, assume IST
            login_date = self.login_time.replace(tzinfo=ist).date()
        
        if now_ist.date() > login_date:
            # It's a day after the login date
            if now_ist.time() >= expiry_time:
                # It's after 6 AM on a subsequent day
                return True
        
        return False 